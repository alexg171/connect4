class Piece:
    Player1 = 1
    Player2 = 2
    Empty = 3


connect = 4


class Board:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.data = [[Piece.Empty for x in range(width)] for x in range(height)]
        self.fullColumns = []

    def drop(self, x, value):
        if (x in self.fullColumns):
            print("Column full")
        else:
            drop_col = self.getDropY(x)
            self.set(x, drop_col, value)
    def getColumns(self):
        return self.width
    def getFullColums(self):
        return self.fullColumns
    def getDropY(self, x):
        for i in reversed(range(self.height)):
            if self.data[x][i] == Piece.Empty:
                if i == 0:
                    self.fullColumns.append(x)
                return i

    def set(self, x, y, value):
        self.data[x][y] = value

    def get(self, x, y):
        return self.data[x][y]

    def print(self):
        for j in range(self.height):
            for i in range(self.width):
                print(self.data[i][j], " ", end='')
            print(end="\n")

    def checkEnd(self):
        count = 0;
        for i in range(self.width):
            for j in range(self.height):
                # diag right
                for k in range(connect - 1):
                    if i + k + 1 > self.width - 1 or j + k + 1 > self.height - 1:
                        break
                    if self.data[i + k][j + k] == self.data[i + k + 1][j + k + 1] and self.data[i][j] != 3:
                        count = count + 1
                        if count == connect - 1:
                            if (self.data[i][j] == 1):
                                return 1
                            if (self.data[i][j] == 2):
                                return 2
                    else:
                        break
                count = 0
                # diag left
                for k in range(connect - 1):
                    if i - k - 1 < 0 or j - k - 1 < 0:
                        break
                    if self.data[i - k][j - k] == self.data[i - k - 1][j - k - 1] and self.data[i][j] != 3:
                        count = count + 1
                        if count == connect - 1:
                            if (self.data[i][j] == 1):
                                return 1
                            if (self.data[i][j] == 2):
                                return 2
                    else:
                        break
                count = 0
                # horiz
                for k in range(connect - 1):
                    if i + k + 1 > self.width - 1:
                        break
                    if self.data[i + k][j] == self.data[i + k + 1][j] and self.data[i][j] != 3:
                        count = count + 1
                        if count == connect - 1:
                            if (self.data[i][j] == 1):
                                return 1
                            if (self.data[i][j] == 2):
                                return 2
                    else:
                        break
                count = 0
                # vert
                for k in range(connect - 1):
                    if j + k + 1 > self.height - 1:
                        break
                    if self.data[i][j + k] == self.data[i][j + k + 1] and self.data[i][j] != 3:
                        count = count + 1
                        if count == connect - 1:
                            if (self.data[i][j] == 1):
                                return 1
                            if (self.data[i][j] == 2):
                                return 2
                    else:
                        break
                count = 0
        return -1;


class DecisionNode:
    def __init__(self, board, children, move):
        self.children = []
        self.board = board
        self.value = 0
        self.aimove = move

    def addChild(self, node):
        self.children.append(node)

    def getValue(self):
        if self.board.checkEnd() == 2:
            return 100

    def getChildren(self):
        return self.children


class DecisionTree:
    def __init__(self, currentBoard):
        self.root = DecisionNode(currentBoard, [], -1)
        self.levelcount = 0

    def generateTree(self, node, levels):
        print("level",self.levelcount)
        self.levelcount = self.levelcount + 1
        if(self.levelcount < levels):
            for i in range(node.board.getColumns()):
                if i not in node.board.getFullColums():
                    newboard = node.board
                    newboard.drop(i, 2)
                    print("\n\n")
                    newboard.print()
                    child = DecisionNode(newboard, [], i)
                    node.children.append(child)

def main():
    example = Board(5, 5)
    example.drop(0, 1)
    example.drop(1, 2)
    # example.drop(0,1)
    example.drop(0, 1)
    example.drop(0, 1)
    example.drop(0, 1)
    example.drop(1, 2)
    example.drop(1, 1)
    example.drop(2, 2)
    # example.drop(2,1)
    example.drop(3, 1)
    example.print();
    print(example.checkEnd());

    tree = DecisionTree(example)
    node = tree.root
    tree.generateTree(node, 3)


if __name__ == "__main__": main()
